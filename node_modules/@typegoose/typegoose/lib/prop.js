"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const mongoose = require("mongoose");
const util_1 = require("util");
const constants_1 = require("./internal/constants");
const data_1 = require("./internal/data");
const errors_1 = require("./internal/errors");
const utils = require("./internal/utils");
const logSettings_1 = require("./logSettings");
const typegoose_1 = require("./typegoose");
const types_1 = require("./types");
/**
 * Base Function for prop & arrayProp
 * @param input All the options needed for prop's
 */
function baseProp(input) {
    const { Type, key, origOptions, target, whatis } = input;
    if (Type === target.constructor) { // prevent "infinite" buildSchema loop / Maximum Stack size exceeded
        throw new TypeError('It seems like the type used is the same as the target class, which is currently not supported\n'
            + `Please look at https://github.com/typegoose/typegoose/issues/42 for more infomation, for now please avoid using it!`);
    }
    // assign a Unique ID to the target class
    utils.createUniqueID(target);
    const existingMapForTarget = Reflect.getOwnMetadata(constants_1.DecoratorKeys.PropCache, target);
    if (utils.isNullOrUndefined(existingMapForTarget)) {
        Reflect.defineMetadata(constants_1.DecoratorKeys.PropCache, new Map(), target);
    }
    const mapForTarget = (existingMapForTarget !== null && existingMapForTarget !== void 0 ? existingMapForTarget : Reflect.getOwnMetadata(constants_1.DecoratorKeys.PropCache, target));
    mapForTarget.set(key, { origOptions, Type, target, key, whatis });
    logSettings_1.logger.debug('Added "%s.%s" to the Decorator Cache', utils.getName(target.constructor), key);
}
/**
 * Function that is the actual processing of the prop's (used for caching)
 * @param input All the options needed for prop's
 */
function _buildPropMetadata(input) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q;
    let { Type } = input;
    const { key, origOptions, target, whatis } = input;
    const rawOptions = Object.assign({}, origOptions);
    logSettings_1.logger.debug('Starting to process "%s.%s"', target.constructor.name, key);
    if (!utils.isNullOrUndefined(rawOptions.type)) {
        logSettings_1.logger.info('Prop Option "type" is set to', rawOptions.type);
        Type = rawOptions.type;
    }
    if (utils.isNotDefined(Type) && utils.isNullOrUndefined(rawOptions.type)) {
        typegoose_1.buildSchema(Type, { _id: typeof rawOptions._id === 'boolean' ? rawOptions._id : true });
    }
    const name = utils.getName(target.constructor);
    if (!data_1.virtuals.has(name)) {
        data_1.virtuals.set(name, new Map());
    }
    if (utils.isWithVirtualPOP(rawOptions)) {
        if (!utils.includesAllVirtualPOP(rawOptions)) {
            throw new errors_1.NotAllVPOPElementsError(name, key);
        }
        data_1.virtuals.get(name).set(key, rawOptions);
        return;
    }
    utils.initProperty(name, key, whatis);
    if (!utils.isNullOrUndefined(rawOptions.set) || !utils.isNullOrUndefined(rawOptions.get)) {
        if (typeof ((_a = rawOptions) === null || _a === void 0 ? void 0 : _a.set) !== 'function') {
            throw new TypeError(`"${name}.${key}" does not have a set function!`);
        }
        if (typeof ((_b = rawOptions) === null || _b === void 0 ? void 0 : _b.get) !== 'function') {
            throw new TypeError(`"${name}.${key}" does not have a get function!`);
        }
        const newType = ((_c = rawOptions) === null || _c === void 0 ? void 0 : _c.type) ? rawOptions.type : Type;
        if (!utils.isNullOrUndefined((_d = rawOptions) === null || _d === void 0 ? void 0 : _d.type)) {
            delete rawOptions.type;
        }
        /*
         * Note:
         * this dosnt have a check if prop & returntype of the function is the same,
         * because it cant be accessed at runtime
         */
        data_1.schemas.get(name)[key] = Object.assign(Object.assign(Object.assign({}, data_1.schemas.get(name)[key]), { type: newType }), rawOptions);
        return;
    }
    const ref = (_e = rawOptions) === null || _e === void 0 ? void 0 : _e.ref;
    const refType = (_j = (_g = (_f = rawOptions) === null || _f === void 0 ? void 0 : _f.refType, (_g !== null && _g !== void 0 ? _g : (_h = rawOptions) === null || _h === void 0 ? void 0 : _h.type)), (_j !== null && _j !== void 0 ? _j : mongoose.Schema.Types.ObjectId));
    if (!utils.isNullOrUndefined(ref)) {
        delete rawOptions.ref;
        const refName = typeof ref === 'string' ? ref : utils.getName(ref);
        switch (whatis) {
            case types_1.WhatIsIt.ARRAY:
                data_1.schemas.get(name)[key][0] = Object.assign(Object.assign(Object.assign({}, data_1.schemas.get(name)[key][0]), { type: refType, ref: refName }), rawOptions);
                break;
            case types_1.WhatIsIt.NONE:
                data_1.schemas.get(name)[key] = Object.assign(Object.assign(Object.assign({}, data_1.schemas.get(name)[key]), { type: refType, ref: refName }), rawOptions);
                break;
            default:
                throw new TypeError(util_1.format('"ref" is not supported for "%s"! (%s, %s)', whatis, utils.getName(target), key));
        }
        return;
    }
    const refPath = (_k = rawOptions) === null || _k === void 0 ? void 0 : _k.refPath;
    if (refPath) {
        if (typeof refPath !== 'string') {
            throw new TypeError(util_1.format('"refPath" for "%s, %s" should be of type String!', utils.getName(target), key));
        }
        delete rawOptions.refPath;
        switch (whatis) {
            case types_1.WhatIsIt.ARRAY:
                data_1.schemas.get(name)[key][0] = Object.assign(Object.assign(Object.assign({}, data_1.schemas.get(name)[key][0]), { type: refType, refPath }), rawOptions);
                break;
            case types_1.WhatIsIt.NONE:
                data_1.schemas.get(name)[key] = Object.assign(Object.assign(Object.assign({}, data_1.schemas.get(name)[key]), { type: refType, refPath }), rawOptions);
                break;
            default:
                throw new TypeError(util_1.format('"refPath" is not supported for "%s"! (%s, %s)', whatis, utils.getName(target), key));
        }
        return;
    }
    const enumOption = (_l = rawOptions) === null || _l === void 0 ? void 0 : _l.enum;
    if (!utils.isNullOrUndefined(enumOption)) {
        if (!Array.isArray(enumOption)) {
            // the following "if" it to not break existing databases
            if ((_o = (_m = data_1.globalOptions) === null || _m === void 0 ? void 0 : _m.globalOptions) === null || _o === void 0 ? void 0 : _o.useNewEnum) {
                rawOptions.enum = Object.entries(enumOption) // get all key-value pairs of the enum
                    // filter out the "reverse (value -> name) mappings"
                    // https://www.typescriptlang.org/docs/handbook/enums.html#reverse-mappings
                    .filter(([enumKey, enumValue]) => {
                    return Number.isNaN(parseInt(enumKey, 10));
                })
                    .map(([enumKey, enumValue], i, enumArray) => {
                    if (typeof enumValue !== 'string') { // disallow the use of enums that dont have strings associated with them
                        throw new TypeError(util_1.format('All Enums supplied to @prop must have strings associated with them!\n'
                            + 'Encountered at "%s.%s", with property: %s.%s', utils.getName(target.constructor), key, enumKey, typeof enumValue));
                    }
                    return enumValue;
                });
            }
            else {
                // old behaviour
                // TODO: remove in typegoose 7.0
                logSettings_1.logger.warn('Old Enum Behaviour is used, please upgrade to the new one');
                rawOptions.enum = Object.keys(enumOption).map((propKey) => enumOption[propKey]);
            }
        }
    }
    const selectOption = (_p = rawOptions) === null || _p === void 0 ? void 0 : _p.select;
    if (typeof selectOption === 'boolean') {
        data_1.schemas.get(name)[key] = Object.assign(Object.assign({}, data_1.schemas.get(name)[key]), { select: selectOption });
    }
    {
        // check if Type is actually a real working Type
        if (utils.isNullOrUndefined(Type) || typeof Type !== 'function') {
            throw new errors_1.InvalidTypeError(target.constructor.name, key, Type);
        }
        // check for validation inconsistencies
        if (utils.isWithStringValidate(rawOptions) && !utils.isString(Type)) {
            throw new errors_1.NotStringTypeError(key);
        }
        // check for transform inconsistencies
        if (utils.isWithStringTransform(rawOptions) && !utils.isString(Type)) {
            throw new errors_1.NotStringTypeError(key);
        }
        if (utils.isWithNumberValidate(rawOptions) && !utils.isNumber(Type)) {
            throw new errors_1.NotNumberTypeError(key);
        }
    }
    const subSchema = data_1.schemas.get(utils.getName(Type));
    if (!subSchema && !utils.isPrimitive(Type) && !utils.isObject(Type)) {
        throw new errors_1.InvalidPropError(Type.name, key); // This seems to be never thrown!
    }
    const { ['items']: items } = rawOptions, options = tslib_1.__rest(rawOptions, ['items']);
    if (utils.isPrimitive(Type)) {
        switch (whatis) {
            case types_1.WhatIsIt.ARRAY:
                data_1.schemas.get(name)[key] = Object.assign(Object.assign({}, data_1.schemas.get(name)[key][0]), utils.mapArrayOptions(rawOptions, Type, target, key));
                return;
            case types_1.WhatIsIt.MAP:
                // "default" is a reserved keyword, thats why "_default" is used
                const { default: _default } = options;
                delete options.default;
                delete options.of;
                data_1.schemas.get(name)[key] = Object.assign(Object.assign({}, data_1.schemas.get(name)[key]), { type: Map, default: _default, of: Object.assign({ type: Type }, options) });
                return;
            case types_1.WhatIsIt.NONE:
                data_1.schemas.get(name)[key] = Object.assign(Object.assign(Object.assign({}, data_1.schemas.get(name)[key]), options), { type: Type });
                return;
            default:
                throw new Error(`"${whatis}"(whatis(primitive)) is invalid for "${name}.${key}"`);
        }
    }
    // If the 'Type' is not a 'Primitive Type' and no subschema was found treat the type as 'Object'
    // so that mongoose can store it as nested document
    if (utils.isObject(Type) && !subSchema) {
        utils.warnMixed(target, key);
        data_1.schemas.get(name)[key] = Object.assign(Object.assign(Object.assign({}, data_1.schemas.get(name)[key]), options), { type: mongoose.Schema.Types.Mixed });
        return;
    }
    const virtualSchema = typegoose_1.buildSchema(Type, {
        _id: typeof ((_q = rawOptions) === null || _q === void 0 ? void 0 : _q._id) === 'boolean' ? rawOptions._id : true
    });
    switch (whatis) {
        case types_1.WhatIsIt.ARRAY:
            data_1.schemas.get(name)[key] = Object.assign(Object.assign(Object.assign({}, data_1.schemas.get(name)[key][0]), options), { type: [virtualSchema] });
            return;
        case types_1.WhatIsIt.MAP:
            data_1.schemas.get(name)[key] = Object.assign(Object.assign({}, data_1.schemas.get(name)[key]), { type: Map, of: Object.assign({ type: virtualSchema }, options) });
            return;
        case types_1.WhatIsIt.NONE:
            data_1.schemas.get(name)[key] = Object.assign(Object.assign(Object.assign({}, data_1.schemas.get(name)[key]), options), { type: virtualSchema });
            return;
        default:
            throw new Error(`"${whatis}"(whatis(subSchema)) is invalid for "${name}.${key}"`);
    }
}
exports._buildPropMetadata = _buildPropMetadata;
/**
 * Set Property Options for the property below
 * @param options Options
 * @public
 */
function prop(options = {}) {
    return (target, key) => {
        const Type = Reflect.getMetadata(constants_1.DecoratorKeys.Type, target, key);
        if (utils.isNullOrUndefined(Type)) {
            throw new errors_1.NoMetadataError(key);
        }
        // soft errors
        {
            if ('items' in options) {
                logSettings_1.logger.warn('You might not want to use option "items" in a @prop, use @arrayProp (%s.%s)', utils.getName(target), key);
            }
            if ('of' in options) {
                logSettings_1.logger.warn('You might not want to use option "of" in a @prop, use @mapProp (%s.%s)', utils.getName(target), key);
            }
        }
        baseProp({
            Type,
            key,
            origOptions: options,
            target,
            whatis: types_1.WhatIsIt.NONE
        });
    };
}
exports.prop = prop;
/**
 * Set Property(that are Maps) Options for the property below
 * @param options Options for the Map
 * @public
 */
function mapProp(options) {
    return (target, key) => {
        var _a;
        const Type = (_a = options) === null || _a === void 0 ? void 0 : _a.of;
        if ('items' in options) {
            logSettings_1.logger.warn('You might not want to use option "items" in a @mapProp, use @arrayProp (%s.%s)', utils.getName(target), key);
        }
        baseProp({
            Type,
            key,
            origOptions: options,
            target,
            whatis: types_1.WhatIsIt.MAP
        });
    };
}
exports.mapProp = mapProp;
/**
 * Set Property(that are Arrays) Options for the property below
 * @param options Options
 * @public
 */
function arrayProp(options) {
    return (target, key) => {
        var _a;
        const Type = (_a = options) === null || _a === void 0 ? void 0 : _a.items;
        if ('of' in options) {
            logSettings_1.logger.warn('You might not want to use option "of" in a @arrayProp, use @mapProp (%s.%s)', utils.getName(target), key);
        }
        if ('items' in options) {
            delete options.items;
        }
        if ('itemsRef' in options) {
            options.ref = options.itemsRef;
            delete options.itemsRef;
        }
        if ('itemsRefPath' in options) {
            options.refPath = options.itemsRefPath;
            delete options.itemsRefPath;
        }
        if ('itemsRefType' in options) {
            options.refType = options.itemsRefType;
            delete options.itemsRefType;
        }
        baseProp({
            Type,
            key,
            origOptions: options,
            target,
            whatis: types_1.WhatIsIt.ARRAY
        });
    };
}
exports.arrayProp = arrayProp;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHJvcC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3NyYy9wcm9wLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBLHFDQUFxQztBQUNyQywrQkFBOEI7QUFFOUIsb0RBQXFEO0FBQ3JELDBDQUFtRTtBQUNuRSw4Q0FPMkI7QUFFM0IsMENBQTBDO0FBQzFDLCtDQUF1QztBQUN2QywyQ0FBMEM7QUFDMUMsbUNBUWlCO0FBRWpCOzs7R0FHRztBQUNILFNBQVMsUUFBUSxDQUFDLEtBQWdDO0lBQ2hELE1BQU0sRUFDSixJQUFJLEVBQ0osR0FBRyxFQUNILFdBQVcsRUFDWCxNQUFNLEVBQ04sTUFBTSxFQUNQLEdBQUcsS0FBSyxDQUFDO0lBQ1YsSUFBSSxJQUFJLEtBQUssTUFBTSxDQUFDLFdBQVcsRUFBRSxFQUFFLG9FQUFvRTtRQUNyRyxNQUFNLElBQUksU0FBUyxDQUFDLGlHQUFpRztjQUNqSCxxSEFBcUgsQ0FBQyxDQUFDO0tBQzVIO0lBRUQseUNBQXlDO0lBQ3pDLEtBQUssQ0FBQyxjQUFjLENBQUMsTUFBTSxDQUFDLENBQUM7SUFFN0IsTUFBTSxvQkFBb0IsR0FBRyxPQUFPLENBQUMsY0FBYyxDQUFDLHlCQUFhLENBQUMsU0FBUyxFQUFFLE1BQU0sQ0FBaUMsQ0FBQztJQUNySCxJQUFJLEtBQUssQ0FBQyxpQkFBaUIsQ0FBQyxvQkFBb0IsQ0FBQyxFQUFFO1FBQ2pELE9BQU8sQ0FBQyxjQUFjLENBQUMseUJBQWEsQ0FBQyxTQUFTLEVBQUUsSUFBSSxHQUFHLEVBQXFDLEVBQUUsTUFBTSxDQUFDLENBQUM7S0FDdkc7SUFDRCxNQUFNLFlBQVksSUFBRyxvQkFBb0IsYUFBcEIsb0JBQW9CLGNBQXBCLG9CQUFvQixHQUNwQyxPQUFPLENBQUMsY0FBYyxDQUFDLHlCQUFhLENBQUMsU0FBUyxFQUFFLE1BQU0sQ0FBaUMsQ0FBQSxDQUFDO0lBRTdGLFlBQVksQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFFLEVBQUUsV0FBVyxFQUFFLElBQUks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
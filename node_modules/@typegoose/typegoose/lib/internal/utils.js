"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const lodash_1 = require("lodash");
const mongoose = require("mongoose");
const util_1 = require("util");
const logSettings_1 = require("../logSettings");
const types_1 = require("../types");
const constants_1 = require("./constants");
const data_1 = require("./data");
const errors_1 = require("./errors");
/**
 * Returns true, if the type is included in mongoose.Schema.Types
 * @param Type The Type
 * @returns true, if it includes it
 */
function isPrimitive(Type) {
    if (Type && typeof Type.name === 'string') {
        // try to match "Type.name" with all the Property Names of "mongoose.Schema.Types"
        // (like "String" with "mongoose.Schema.Types.String")
        return Object.getOwnPropertyNames(mongoose.Schema.Types).includes(Type.name)
            // try to match "Type.name" with all "mongoose.Schema.Types.*.name"
            // (like "SchemaString" with "mongoose.Schema.Types.String.name")
            || Object.values(mongoose.Schema.Types).findIndex((v) => v.name === Type.name) >= 0;
    }
    return false;
}
exports.isPrimitive = isPrimitive;
/**
 * Returns true, if it is an Object
 * @param Type The Type
 * @returns true, if it is an Object
 */
function isObject(Type) {
    var _a, _b;
    if (typeof ((_a = Type) === null || _a === void 0 ? void 0 : _a.name) === 'string') {
        let prototype = Type.prototype;
        let name = Type.name;
        while (name) {
            if (name === 'Object') {
                return true;
            }
            prototype = Object.getPrototypeOf(prototype);
            name = (_b = prototype) === null || _b === void 0 ? void 0 : _b.constructor.name;
        }
    }
    return false;
}
exports.isObject = isObject;
/**
 * Returns true, if it is an Number
 * @param Type The Type
 * @returns true, if it is an Number
 */
function isNumber(Type) {
    var _a;
    return ((_a = Type) === null || _a === void 0 ? void 0 : _a.name) === 'Number';
}
exports.isNumber = isNumber;
/**
 * Returns true, if it is an String
 * @param Type The Type
 * @returns true, if it is an String
 */
function isString(Type) {
    var _a;
    return ((_a = Type) === null || _a === void 0 ? void 0 : _a.name) === 'String';
}
exports.isString = isString;
/**
 * Initialize the property in the schemas Map
 * @param name Name of the current Model/Class
 * @param key Key of the property
 * @param whatis What should it be for a type?
 */
function initProperty(name, key, whatis) {
    if (!data_1.schemas.has(name)) {
        data_1.schemas.set(name, {});
    }
    switch (whatis) {
        case types_1.WhatIsIt.ARRAY:
            data_1.schemas.get(name)[key] = [{}];
            break;
        case types_1.WhatIsIt.MAP:
        case types_1.WhatIsIt.NONE:
            data_1.schemas.get(name)[key] = {};
            break;
        default:
            throw new TypeError('"whatis" is not supplied OR dosnt have a case yet!');
    }
}
exports.initProperty = initProperty;
/**
 * Get the Class for a given Document
 * @param document The Document
 */
function getClassForDocument(document) {
    const modelName = document.constructor.modelName;
    return data_1.constructors.get(modelName);
}
exports.getClassForDocument = getClassForDocument;
/**
 * Return true if there are Options
 * @param options The raw Options
 */
function isWithStringValidate(options) {
    var _a, _b, _c, _d, _e, _f, _g;
    return !isNullOrUndefined((_f = (_d = (_b = (_a = options) === null || _a === void 0 ? void 0 : _a.match, (_b !== null && _b !== void 0 ? _b : (_c = options) === null || _c === void 0 ? void 0 : _c.enum)), (_d !== null && _d !== void 0 ? _d : (_e = options) === null || _e === void 0 ? void 0 : _e.minlength)), (_f !== null && _f !== void 0 ? _f : (_g = options) === null || _g === void 0 ? void 0 : _g.maxlength)));
}
exports.isWithStringValidate = isWithStringValidate;
/**
 * Return true if there are Options
 * @param options The raw Options
 */
function isWithStringTransform(options) {
    var _a, _b;
    return !isNullOrUndefined((_b = (_a = options.lowercase, (_a !== null && _a !== void 0 ? _a : options.uppercase)), (_b !== null && _b !== void 0 ? _b : options.trim)));
}
exports.isWithStringTransform = isWithStringTransform;
/**
 * Return true if there are Options
 * @param options The raw Options
 */
function isWithNumberValidate(options) {
    var _a;
    return !isNullOrUndefined((_a = options.min, (_a !== null && _a !== void 0 ? _a : options.max)));
}
exports.isWithNumberValidate = isWithNumberValidate;
const virtualOptions = ['localField', 'foreignField'];
/**
 * Check if Options include Virtual Populate Options
 * @param options RawOptions of the Prop
 */
function isWithVirtualPOP(options) {
    return Object.keys(options).some((v) => virtualOptions.includes(v));
}
exports.isWithVirtualPOP = isWithVirtualPOP;
exports.allVirtualoptions = virtualOptions.slice(0);
exports.allVirtualoptions.push('ref');
/**
 * Check if All the required Options are present
 * @param options RawOptions of the Prop
 */
function includesAllVirtualPOP(options) {
    return exports.allVirtualoptions.every((v) => Object.keys(options).includes(v));
}
exports.includesAllVirtualPOP = includesAllVirtualPOP;
/**
 * Merge value & existing Metadata & Save it to the class
 * Difference with "mergeMetadata" is that this one DOES save it to the class
 * @param key Metadata key
 * @param value Raw value
 * @param cl The constructor
 * @internal
 */
function assignMetadata(key, value, cl) {
    if (isNullOrUndefined(value)) {
        return value;
    }
    const newValue = mergeMetadata(key, value, cl);
    Reflect.defineMetadata(key, newValue, cl);
    return newValue;
}
exports.assignMetadata = assignMetadata;
/**
 * Merge value & existing Metadata
 * Difference with "assignMetadata" is that this one DOES NOT save it to the class
 * @param key Metadata key
 * @param value Raw value
 * @param cl The constructor
 * @internal
 */
function mergeMetadata(key, value, cl) {
    var _a;
    if (typeof key !== 'string') {
        throw new TypeError(`"${key}"(key) is not a string! (assignMetadata)`);
    }
    if (typeof cl !== 'function') {
        throw new errors_1.NoValidClass(cl);
    }
    // Please dont remove the other values from the function, even when unused - it is made to be clear what is what
    const current = lodash_1.cloneDeepWith((_a = Reflect.getMetadata(key, cl), (_a !== null && _a !== void 0 ? _a : {})), (val, ckey, obj, stack) => customMerger(key, val));
    return lodash_1.mergeWith({}, current, value, (objValue, srcValue, ckey, object, source, stack) => customMerger(key, srcValue));
}
exports.mergeMetadata = mergeMetadata;
/**
 * Used for lodash customizer's (cloneWith, cloneDeepWith, mergeWith)
 * @param key the key of the current object
 * @param val the value of the object that should get returned for "existingMongoose" & "existingConnection"
 */
function customMerger(key, val) {
    if (isNullOrUndefined(key) || typeof key !== 'string') {
        return undefined;
    }
    if (/^(existingMongoose|existingConnection)$/.test(key)) {
        return val;
    }
    return undefined;
}
/**
 * Merge only schemaOptions from ModelOptions of the class
 * @param value The value to use
 * @param cl The Class to get the values from
 */
function mergeSchemaOptions(value, cl) {
    return mergeMetadata(constants_1.DecoratorKeys.ModelOptions, { schemaOptions: value }, cl).schemaOptions;
}
exports.mergeSchemaOptions = mergeSchemaOptions;
/**
 * Get the correct name of the class's model
 * (with suffix)
 * @param cl The Class
 */
function getName(cl) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    const options = (_a = Reflect.getMetadata(constants_1.DecoratorKeys.ModelOptions, cl), (_a !== null && _a !== void 0 ? _a : {}));
    const baseName = cl.name;
    if (options.options && options.options.automaticName) {
        const suffix = (_d = (_c = (_b = options) === null || _b === void 0 ? void 0 : _b.options) === null || _c === void 0 ? void 0 : _c.customName, (_d !== null && _d !== void 0 ? _d : (_f = (_e = options) === null || _e === void 0 ? void 0 : _e.schemaOptions) === null || _f === void 0 ? void 0 : _f.collection));
        return !isNullOrUndefined(suffix) ? `${baseName}_${suffix}` : baseName;
    }
    if (typeof ((_h = (_g = options) === null || _g === void 0 ? void 0 : _g.options) === null || _h === void 0 ? void 0 : _h.customName) === 'string') {
        if (options.options.customName.length <= 0) {
            throw new TypeError(`"customName" must be a string AND at least one character ("${cl.name}")`);
        }
        return options.options.customName;
    }
    return baseName;
}
exports.getName = getName;
/**
 * Returns if it is not defined in "schemas"
 * @param cl The Type
 */
function isNotDefined(cl) {
    return typeof cl === 'function' &&
        !isPrimitive(cl) &&
        cl !== Object &&
        cl !== mongoose.Schema.Types.Buffer &&
        isNullOrUndefined(data_1.schemas.get(getName(cl)));
}
exports.isNotDefined = isNotDefined;
/**
 * Assign "__uniqueID" to a class
 * @param cl
 * @returns boolean, true if uniqueID is created, false if already existing
 */
function createUniqueID(cl) {
    if (isNullOrUndefined(cl.__uniqueID)) {
        cl.__uniqueID = Date.now();
        return true;
    }
    return false;
}
exports.createUniqueID = createUniqueID;
/**
 * Map Options to "inner" & "outer"
 * -> inner: means inner of "type: [{here})"
 * -> outer: means outer of "type: [{}], here"
 * @param rawOptions The raw options
 * @param Type The Type of the array
 * @param target The Target class
 * @param pkey Key of the Property
 */
function mapArrayOptions(rawOptions, Type, target, pkey) {
    var _a, _b;
    if (getName(Type) in mongoose.Schema.Types) {
        logSettings_1.logger.info('Converting "%s" to mongoose Type', getName(Type));
        Type = mongoose.Schema.Types[getName(Type)];
        /* istanbul ignore next */
        if (Type === mongoose.Schema.Types.Mixed) {
            warnMixed(target, pkey);
        }
    }
    if (isNullOrUndefined(Type.prototype.OptionsConstructor)) {
        throw new TypeError('Type does not have an valid "OptionsConstructor"!');
    }
    const options = Object.assign({}, rawOptions); // for sanity
    delete options.items;
    const returnObject = {
        type: [{
                type: Type
            }]
    };
    // "mongoose as any" is because the types package does not yet have an entry for "SchemaTypeOptions"
    if (Type.prototype.OptionsConstructor.prototype instanceof mongoose.SchemaTypeOptions) {
        for (const [key, value] of Object.entries(options)) {
            if (Object.getOwnPropertyNames(Type.prototype.OptionsConstructor.prototype).includes(key)) {
                returnObject.type[0][key] = value;
            }
            else {
                returnObject[key] = value;
            }
        }
    }
    else {
        logSettings_1.logger.info('The Type "%s" does not have an OptionsConstructor', getName(Type));
    }
    if (typeof ((_a = options) === null || _a === void 0 ? void 0 : _a.innerOptions) === 'object') {
        for (const [key, value] of Object.entries(options.innerOptions)) {
            returnObject.type[0][key] = value;
        }
    }
    if (typeof ((_b = options) === null || _b === void 0 ? void 0 : _b.outerOptions) === 'object') {
        for (const [key, value] of Object.entries(options.outerOptions)) {
            returnObject[key] = value;
        }
    }
    logSettings_1.logger.debug('Final mapped Options for Type "%s"', getName(Type), returnObject);
    return returnObject;
}
exports.mapArrayOptions = mapArrayOptions;
/**
 * Warn, Error or Allow if an mixed type is set
 * -> this function exists for de-duplication
 * @param target Target Class
 * @param key Property key
 */
function warnMixed(target, key) {
    var _a, _b, _c;
    const name = getName(target);
    const modelOptions = (_a = Reflect.getMetadata(constants_1.DecoratorKeys.ModelOptions, target), (_a !== null && _a !== void 0 ? _a : {}));
    switch ((_c = (_b = modelOptions) === null || _b === void 0 ? void 0 : _b.options) === null || _c === void 0 ? void 0 : _c.allowMixed) {
        default:
        case types_1.Severity.WARN:
            logSettings_1.logger.warn('Implicitly setting "Mixed" is not allowed! (%s, %s)', name, key);
            break;
        case types_1.Severity.ALLOW:
            break;
        case types_1.Severity.ERROR:
            throw new TypeError(util_1.format('Implicitly setting "Mixed" is not allowed! (%s, %s)', name, key));
    }
    return; // always return, if "allowMixed" is not "ERROR"
}
exports.warnMixed = warnMixed;
/**
 * Because since node 4.0.0 the internal util.is* functions got deprecated
 * @param val Any value to test if null or undefined
 */
function isNullOrUndefined(val) {
    return val === null || val === undefined;
}
exports.isNullOrUndefined = isNullOrUndefined;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvaW50ZXJuYWwvdXRpbHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSxtQ0FBa0Q7QUFDbEQscUNBQXFDO0FBQ3JDLCtCQUE4QjtBQUU5QixnREFBd0M7QUFDeEMsb0NBUWtCO0FBQ2xCLDJDQUE0QztBQUM1QyxpQ0FBK0M7QUFDL0MscUNBQXdDO0FBRXhDOzs7O0dBSUc7QUFDSCxTQUFnQixXQUFXLENBQUMsSUFBUztJQUNuQyxJQUFJLElBQUksSUFBSSxPQUFPLElBQUksQ0FBQyxJQUFJLEtBQUssUUFBUSxFQUFFO1FBQ3pDLGtGQUFrRjtRQUNsRixzREFBc0Q7UUFDdEQsT0FBTyxNQUFNLENBQUMsbUJBQW1CLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQztZQUMxRSxtRUFBbUU7WUFDbkUsaUVBQWlFO2VBQzlELE1BQU0sQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJLEtBQUssSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztLQUN2RjtJQUVELE9BQU8sS0FBSyxDQUFDO0FBQ2YsQ0FBQztBQVhELGtDQVdDO0FBRUQ7Ozs7R0FJRztBQUNILFNBQWdCLFFBQVEsQ0FBQyxJQUFTOztJQUNoQyxJQUFJLGNBQU8sSUFBSSwwQ0FBRSxJQUFJLENBQUEsS0FBSyxRQUFRLEVBQUU7UUFDbEMsSUFBSSxTQUFTLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQztRQUMvQixJQUFJLElBQUksR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDO1FBQ3JCLE9BQU8sSUFBSSxFQUFFO1lBQ1gsSUFBSSxJQUFJLEtBQUssUUFBUSxFQUFFO2dCQUNyQixPQUFPLElB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